-- Verbessertes Drawing-Library (kompatibel zur bisherigen API)
-- Vollständiger Code: ersetze deine alte Datei damit
-- Hinweise: Teste in deinem Exploit/Executor-Umfeld. Einige UI-Details hängen von der Laufzeitumgebung ab.

local RunService = game:GetService("RunService")
local TextService = game:GetService("TextService")

-- Utility
local function round(n) return math.floor(n + 0.5) end
local function clamp(v, a, b) return math.clamp(v, a, b) end

-- Safe getgenv Instance / CoreGui references wie vorher
task.spawn(function()
	repeat task.wait() until getgenv().Instance and getgenv().game
end)

-- Erstelle/halte das Drawing ScreenGui
local function ensureDrawingGui()
	if getgenv()._DrawingGui and getgenv()._DrawingGui.Parent then
		return getgenv()._DrawingGui
	end

	local gui = getgenv().Instance.new("ScreenGui", getgenv().game:GetService("CoreGui"))
	gui.Name = "Drawing"
	gui.IgnoreGuiInset = true
	gui.DisplayOrder = 0x7fffffff
	getgenv()._DrawingGui = gui
	return gui
end

local drawingUI = ensureDrawingGui()

-- Pools für UI-Objekte zum Wiederverwenden
local Pools = {
	Frame = {},
	TextLabel = {},
	ImageLabel = {},
	UIStroke = {},
	UICorner = {}
}

local function poolGet(kind)
	local t = Pools[kind]
	if not t then return nil end
	return table.remove(t)
end

local function poolPut(kind, obj)
	if not obj then return end
	-- Clean minimal props and parent off
	pcall(function()
		if obj:IsA("TextLabel") then
			obj.Text = ""
			obj.Visible = false
			obj.Parent = nil
			obj.TextTransparency = 0
		elseif obj:IsA("Frame") then
			obj.BackgroundTransparency = 1
			obj.Visible = false
			obj.Parent = nil
		elseif obj:IsA("ImageLabel") then
			obj.Visible = false
			obj.Parent = nil
			obj.Image = ""
		elseif obj:IsA("UIStroke") then
			obj.Enabled = false
			obj.Parent = nil
		elseif obj:IsA("UICorner") then
			obj.Parent = nil
		end
	end)
	table.insert(Pools[kind], obj)
end

local function createOrPool(kind)
	local obj = poolGet(kind)
	if obj then return obj end
	-- erzeugen
	if kind == "Frame" then
		local f = getgenv().Instance.new("Frame")
		f.BorderSizePixel = 0
		f.BackgroundColor3 = Color3.new(0,0,0)
		f.BackgroundTransparency = 1
		f.AnchorPoint = Vector2.new(0.5, 0.5)
		return f
	elseif kind == "TextLabel" then
		local t = getgenv().Instance.new("TextLabel")
		t.AnchorPoint = Vector2.new(0.5, 0.5)
		t.BorderSizePixel = 0
		t.BackgroundTransparency = 1
		t.TextTransparency = 0
		t.Size = UDim2.new(0,0,0,0)
		t.TextWrapped = false
		t.RichText = false
		return t
	elseif kind == "ImageLabel" then
		local i = getgenv().Instance.new("ImageLabel")
		i.AnchorPoint = Vector2.new(0.5, 0.5)
		i.BorderSizePixel = 0
		i.BackgroundTransparency = 1
		i.ScaleType = Enum.ScaleType.Stretch
		return i
	elseif kind == "UIStroke" then
		local s = getgenv().Instance.new("UIStroke")
		s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		return s
	elseif kind == "UICorner" then
		local c = getgenv().Instance.new("UICorner")
		return c
	end
	return nil
end

-- Base object prototype (wie vorher)
local baseDrawingObj = setmetatable({
	Visible = true,
	ZIndex = 0,
	Transparency = 1,
	Color = Color3.new(),
	Remove = function(self) setmetatable(self, nil) end,
	Destroy = function(self) setmetatable(self, nil) end
}, {
	__add = function(t1, t2)
		local result = table.clone(t1)
		for index, value in t2 do
			result[index] = value
		end
		return result
	end
})

-- Fonts mapping (klein & kompatibel)
local drawingFontsEnum = {
	[0] = Font.fromEnum(Enum.Font.Roboto),
	[1] = Font.fromEnum(Enum.Font.Legacy),
	[2] = Font.fromEnum(Enum.Font.SourceSans),
	[3] = Font.fromEnum(Enum.Font.RobotoMono),
}

local function convertTransparency(transparency)
	return math.clamp(1 - transparency, 0, 1)
end

-- Zentrales Registry und Renderer
local activeObjects = {} -- { {ui = <inst>, state = {..}, cached = {...}, type = "Line" }, ... }
local drawingIndex = 0

local function setIfChanged(inst, prop, val, cached)
	if cached[prop] == val then return false end
	cached[prop] = val
	inst[prop] = val
	return true
end

-- Text-Messung helper
local function measureText(text, fontFace, size)
	-- fontFace ist Font (Font.fromEnum)
	local fontEnum = fontFace and fontFace.Font or Enum.Font.SourceSans
	local bounds = TextService:GetTextSize(text or "", size or 14, fontEnum, Vector2.new(10000, 10000))
	return bounds
end

-- Renderer: optimiertes Batch-Update
local function rendererStep()
	local gui = ensureDrawingGui()
	if not gui then return end
	local cam = workspace.CurrentCamera
	local viewSize = cam and cam.ViewportSize or Vector2.new(800,600)
	for i = #activeObjects, 1, -1 do
		local entry = activeObjects[i]
		if not entry or entry._removed then
			-- falls markiert zum entfernen: entferne ui/stecken in pool
			if entry and entry.ui then
				local ui = entry.ui
				if ui:IsA("TextLabel") then poolPut("TextLabel", ui) end
				if ui:IsA("Frame") then poolPut("Frame", ui) end
				if ui:IsA("ImageLabel") then poolPut("ImageLabel", ui) end
				if entry.uiStroke then poolPut("UIStroke", entry.uiStroke) end
				if entry.uiCorner then poolPut("UICorner", entry.uiCorner) end
			end
			table.remove(activeObjects, i)
		else
			local st = entry.state
			local cache = entry.cache
			local typ = entry.type

			-- nur rendern wenn sichtbar; aber update cached Visible anyway
			if typ == "Line" then
				local ui = entry.ui
				-- compute
				local from, to = st.From or Vector2.new(), st.To or Vector2.new()
				local dx, dy = (to - from).X, (to - from).Y
				local distance = math.sqrt(dx*dx + dy*dy)
				local center = (from + to) / 2
				local theta = math.deg(math.atan2(dy, dx))

				local pxX, pxY = round(center.X), round(center.Y)
				local pxW, pxH = round(distance), round(st.Thickness or 1)

				-- minimal updates
				setIfChanged(ui, "Position", UDim2.fromOffset(pxX, pxY), cache)
				setIfChanged(ui, "Rotation", theta, cache)
				setIfChanged(ui, "Size", UDim2.fromOffset(pxW, pxH), cache)
				setIfChanged(ui, "ZIndex", st.ZIndex or 0, cache)
				if cache._visible ~= st.Visible then
					cache._visible = st.Visible
					ui.Visible = st.Visible
				end
				local bgT = convertTransparency(st.Transparency or 1)
				if cache._bgT ~= bgT then cache._bgT = bgT; ui.BackgroundTransparency = bgT end
				if cache._color ~= st.Color then cache._color = st.Color; ui.BackgroundColor3 = st.Color end

			elseif typ == "Text" then
				local ui = entry.ui
				local stroke = entry.uiStroke
				local font = drawingFontsEnum[st.Font] or drawingFontsEnum[0]
				local text = st.Text or ""
				local size = st.Size or 14
				local measured = measureText(text, font, size)
				-- position (center handling)
				local pos = st.Position or Vector2.new()
				local pxX, pxY = round(pos.X), round(pos.Y)
				local width, height = round(measured.X), round(measured.Y)

				setIfChanged(ui, "Text", text, cache)
				-- update fontface/size only if changed
				if cache._font ~= font then cache._font = font; ui.FontFace = font end
				if cache._size ~= size then cache._size = size; ui.TextSize = size end

				setIfChanged(ui, "Size", UDim2.fromOffset(width, height), cache)
				if st.Center then
					setIfChanged(ui, "Position", UDim2.fromOffset(round(viewSize.X/2), round(viewSize.Y/2)), cache)
				else
					setIfChanged(ui, "Position", UDim2.fromOffset(pxX + (st.Center and 0 or width/2), pxY + height/2), cache)
				end

				if cache._textColor ~= st.Color then cache._textColor = st.Color; ui.TextColor3 = st.Color end
				local tTrans = convertTransparency(st.Transparency or 1)
				if cache._textT ~= tTrans then cache._textT = tTrans; ui.TextTransparency = tTrans end
				if stroke then
					local enabled = st.Outline or false
					if cache._outline ~= enabled then cache._outline = enabled; stroke.Enabled = enabled end
					if cache._outlineColor ~= st.OutlineColor then cache._outlineColor = st.OutlineColor; stroke.Color = st.OutlineColor end
					if cache._outlineT ~= tTrans then cache._outlineT = tTrans; stroke.Transparency = tTrans end
				end
				if cache._z ~= st.ZIndex then cache._z = st.ZIndex; ui.ZIndex = st.ZIndex end
				if cache._visible ~= st.Visible then cache._visible = st.Visible; ui.Visible = st.Visible end

			elseif typ == "Circle" then
				local ui = entry.ui
				local stroke = entry.uiStroke
				local corner = entry.uiCorner
				local radius = st.Radius or 0
				local pxR = round(radius * 2) -- diameter
				local pos = st.Position or Vector2.new()
				local pxX, pxY = round(pos.X), round(pos.Y)

				setIfChanged(ui, "Size", UDim2.fromOffset(pxR, pxR), entry.cache)
				setIfChanged(ui, "Position", UDim2.fromOffset(pxX, pxY), entry.cache)
				if cache._bgColor ~= st.Color then cache._bgColor = st.Color; ui.BackgroundColor3 = st.Color end
				local tTrans = convertTransparency(st.Transparency or 1)
				if st.Filled then
					if cache._bgT ~= tTrans then cache._bgT = tTrans; ui.BackgroundTransparency = tTrans end
					if stroke then stroke.Enabled = false end
				else
					if cache._bgT ~= 1 then cache._bgT = 1; ui.BackgroundTransparency = 1 end
					if stroke then
						stroke.Enabled = true
						local thickness = clamp(st.Thickness or 1, 0.6, 0x7fffffff)
						if cache._strokeTh ~= thickness then cache._strokeTh = thickness; stroke.Thickness = thickness end
						if cache._strokeColor ~= st.Color then cache._strokeColor = st.Color; stroke.Color = st.Color end
						if cache._strokeT ~= tTrans then cache._strokeT = tTrans; stroke.Transparency = tTrans end
					end
				end
				if cache._z ~= st.ZIndex then cache._z = st.ZIndex; ui.ZIndex = st.ZIndex end
				if cache._visible ~= st.Visible then cache._visible = st.Visible; ui.Visible = st.Visible end

			elseif typ == "Square" then
				local ui = entry.ui
				local stroke = entry.uiStroke
				local sizev = st.Size or Vector2.new()
				local pos = st.Position or Vector2.new()
				local pxW, pxH = round(sizev.X), round(sizev.Y)
				local pxX, pxY = round(pos.X), round(pos.Y)

				setIfChanged(ui, "Size", UDim2.fromOffset(pxW, pxH), cache)
				setIfChanged(ui, "Position", UDim2.fromOffset(pxX, pxY), cache)
				if st.Filled then
					local tTrans = convertTransparency(st.Transparency or 1)
					if cache._bgT ~= tTrans then cache._bgT = tTrans; ui.BackgroundTransparency = tTrans end
					if stroke and stroke.Enabled then stroke.Enabled = false end
				else
					if cache._bgT ~= 1 then cache._bgT = 1; ui.BackgroundTransparency = 1 end
					if stroke then
						stroke.Enabled = true
						local thickness = clamp(st.Thickness or 1, 0.6, 0x7fffffff)
						if cache._strokeTh ~= thickness then cache._strokeTh = thickness; stroke.Thickness = thickness end
						if cache._strokeColor ~= st.Color then cache._strokeColor = st.Color; stroke.Color = st.Color end
						local tTrans = convertTransparency(st.Transparency or 1)
						if cache._strokeT ~= tTrans then cache._strokeT = tTrans; stroke.Transparency = tTrans end
					end
				end
				if cache._color ~= st.Color then cache._color = st.Color; ui.BackgroundColor3 = st.Color end
				if cache._z ~= st.ZIndex then cache._z = st.ZIndex; ui.ZIndex = st.ZIndex end
				if cache._visible ~= st.Visible then cache._visible = st.Visible; ui.Visible = st.Visible end

			elseif typ == "Image" then
				local ui = entry.ui
				local pos = st.Position or Vector2.new()
				local sizev = st.Size or Vector2.new()
				local pxX, pxY = round(pos.X), round(pos.Y)
				local pxW, pxH = round(sizev.X), round(sizev.Y)

				setIfChanged(ui, "Position", UDim2.fromOffset(pxX, pxY), cache)
				setIfChanged(ui, "Size", UDim2.fromOffset(pxW, pxH), cache)
				if cache._img ~= st.Data then cache._img = st.Data; ui.Image = st.Data end
				if cache._imgVisible ~= st.Visible then cache._imgVisible = st.Visible; ui.Visible = st.Visible end
				local tTrans = convertTransparency(st.Transparency or 1)
				if cache._imgT ~= tTrans then cache._imgT = tTrans; ui.ImageTransparency = tTrans end
				if cache._imgColor ~= st.Color then cache._imgColor = st.Color; ui.ImageColor3 = st.Color end
				if cache._z ~= st.ZIndex then cache._z = st.ZIndex; ui.ZIndex = st.ZIndex end
			elseif typ == "Quad" or typ == "Triangle" then
				-- Quads/Triangles implemented via Lines (delegation) - already created as sub-lines
				-- Delegation handled at creation time (no per-frame here)
			end
		end
	end
end

-- Connect renderer
local rendererConn = RunService:IsClient() and RunService.RenderStepped:Connect(rendererStep) or RunService.Heartbeat:Connect(rendererStep)

-- DrawingLib API
local DrawingLib = {}
DrawingLib.Fonts = {
	["UI"] = 0,
	["System"] = 1,
	["Plex"] = 2,
	["Monospace"] = 3
}

-- Create Line / Text / Circle / Square / Image / Quad / Triangle
function DrawingLib.new(drawingType)
	drawingIndex += 1
	local id = tostring(drawingIndex)

	if drawingType == "Line" then
		local lineObj = ({
			From = Vector2.new(0,0),
			To = Vector2.new(0,0),
			Thickness = 1
		} + baseDrawingObj)

		-- Create pooled Frame
		local frame = createOrPool("Frame")
		frame.Name = id
		frame.Parent = drawingUI
		frame.Visible = lineObj.Visible
		frame.BackgroundTransparency = convertTransparency(lineObj.Transparency)
		frame.BackgroundColor3 = lineObj.Color
		frame.ZIndex = lineObj.ZIndex

		-- registre
		local entry = {
			type = "Line",
			ui = frame,
			state = lineObj,
			cache = {}
		}
		table.insert(activeObjects, entry)

		local proxy = setmetatable({__type = "Drawing Object"}, {
			__newindex = function(_, index, value)
				if typeof(lineObj[index]) == "nil" then return end
				-- update state -> renderer hört zu
				lineObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						entry._removed = true
						-- entferne sofort UI und pool es
						if entry.ui then
							local tmp = entry.ui
							entry.ui = nil
							tmp:Destroy() -- direktes Destroy, Pools nehmen es später wieder wenn needed
						end
						lineObj.Remove(self)
					end
				end
				return lineObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
		return proxy

	elseif drawingType == "Text" then
		local textObj = ({
			Text = "",
			Font = DrawingLib.Fonts.UI,
			Size = 14,
			Position = Vector2.new(0,0),
			Center = false,
			Outline = false,
			OutlineColor = Color3.new(),
		} + baseDrawingObj)

		local label = createOrPool("TextLabel")
		label.Name = id
		label.Parent = drawingUI
		label.Visible = textObj.Visible
		label.TextColor3 = textObj.Color
		label.TextTransparency = convertTransparency(textObj.Transparency)
		label.ZIndex = textObj.ZIndex
		label.TextSize = textObj.Size
		label.FontFace = drawingFontsEnum[textObj.Font]

		local stroke = createOrPool("UIStroke")
		stroke.Parent = label
		stroke.Thickness = 1
		stroke.Enabled = textObj.Outline
		stroke.Color = textObj.OutlineColor

		local entry = {
			type = "Text",
			ui = label,
			uiStroke = stroke,
			state = textObj,
			cache = {}
		}
		table.insert(activeObjects, entry)

		local proxy = setmetatable({__type = "Drawing Object"}, {
			__newindex = function(_, index, value)
				if typeof(textObj[index]) == "nil" then return end
				textObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						entry._removed = true
						if entry.ui then entry.ui:Destroy(); entry.ui = nil end
						if entry.uiStroke then entry.uiStroke:Destroy(); entry.uiStroke = nil end
						textObj.Remove(self)
					end
				elseif index == "TextBounds" then
					-- compute via TextService
					local font = drawingFontsEnum[textObj.Font] or drawingFontsEnum[0]
					local measured = measureText(textObj.Text or "", font, textObj.Size)
					return measured
				end
				return textObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
		return proxy

	elseif drawingType == "Circle" then
		local circleObj = ({
			Radius = 150,
			Position = Vector2.new(0,0),
			Thickness = .7,
			Filled = false
		} + baseDrawingObj)

		-- Use Frame + UICorner + UIStroke (pooled)
		local f = createOrPool("Frame")
		f.Name = id
		f.AnchorPoint = Vector2.new(0.5, 0.5)
		f.Parent = drawingUI

		local corner = createOrPool("UICorner")
		corner.CornerRadius = UDim.new(1,0)
		corner.Parent = f

		local stroke = createOrPool("UIStroke")
		stroke.Parent = f
		stroke.Thickness = circleObj.Thickness
		stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		stroke.Enabled = not circleObj.Filled

		local entry = {
			type = "Circle",
			ui = f,
			uiStroke = stroke,
			uiCorner = corner,
			state = circleObj,
			cache = {}
		}
		table.insert(activeObjects, entry)

		local proxy = setmetatable({__type = "Drawing Object"}, {
			__newindex = function(_, index, value)
				if typeof(circleObj[index]) == "nil" then return end
				circleObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						entry._removed = true
						if entry.ui then entry.ui:Destroy(); entry.ui=nil end
						if entry.uiStroke then entry.uiStroke:Destroy(); entry.uiStroke=nil end
						if entry.uiCorner then entry.uiCorner:Destroy(); entry.uiCorner=nil end
						circleObj.Remove(self)
					end
				end
				return circleObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
		return proxy

	elseif drawingType == "Square" then
		local squareObj = ({
			Size = Vector2.new(0,0),
			Position = Vector2.new(0,0),
			Thickness = .7,
			Filled = false
		} + baseDrawingObj)

		local f = createOrPool("Frame")
		f.Name = id
		f.BorderSizePixel = 0
		f.Parent = drawingUI

		local stroke = createOrPool("UIStroke")
		stroke.Parent = f
		stroke.LineJoinMode = Enum.LineJoinMode.Miter
		stroke.Enabled = not squareObj.Filled
		stroke.Thickness = squareObj.Thickness

		local entry = {
			type = "Square",
			ui = f,
			uiStroke = stroke,
			state = squareObj,
			cache = {}
		}
		table.insert(activeObjects, entry)

		local proxy = setmetatable({__type = "Drawing Object"}, {
			__newindex = function(_, index, value)
				if typeof(squareObj[index]) == "nil" then return end
				squareObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						entry._removed = true
						if entry.ui then entry.ui:Destroy(); entry.ui=nil end
						if entry.uiStroke then entry.uiStroke:Destroy(); entry.uiStroke=nil end
						squareObj.Remove(self)
					end
				end
				return squareObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
		return proxy

	elseif drawingType == "Image" then
		local imageObj = ({
			Data = "",
			Size = Vector2.new(0,0),
			Position = Vector2.new(0,0)
		} + baseDrawingObj)

		local img = createOrPool("ImageLabel")
		img.Name = id
		img.Parent = drawingUI
		img.ImageTransparency = convertTransparency(imageObj.Transparency or 1)
		img.ImageColor3 = imageObj.Color
		img.ZIndex = imageObj.ZIndex

		local entry = {
			type = "Image",
			ui = img,
			state = imageObj,
			cache = {}
		}
		table.insert(activeObjects, entry)

		local proxy = setmetatable({__type = "Drawing Object"}, {
			__newindex = function(_, index, value)
				if typeof(imageObj[index]) == "nil" then return end
				imageObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						entry._removed = true
						if entry.ui then entry.ui:Destroy(); entry.ui=nil end
						imageObj.Remove(self)
					end
				end
				return imageObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
		return proxy

	elseif drawingType == "Quad" then
		-- Implementiere Quad über 4 Linien (wie vorher), aber via DrawingLib.new -> Line
		local QuadProperties = ({
			Thickness = 1,
			PointA = Vector2.new(),
			PointB = Vector2.new(),
			PointC = Vector2.new(),
			PointD = Vector2.new(),
			Filled = false
		} + baseDrawingObj)

		local A = DrawingLib.new("Line")
		local B = DrawingLib.new("Line")
		local C = DrawingLib.new("Line")
		local D = DrawingLib.new("Line")

		-- initial linking
		A.Thickness = QuadProperties.Thickness
		B.Thickness = QuadProperties.Thickness
		C.Thickness = QuadProperties.Thickness
		D.Thickness = QuadProperties.Thickness

		local proxy = setmetatable({__type = "Drawing Object"}, {
			__newindex = function(self, Property, Value)
				if Property == "Thickness" then
					A.Thickness = Value; B.Thickness = Value; C.Thickness = Value; D.Thickness = Value
				elseif Property == "PointA" then
					A.From = Value; B.To = Value
				elseif Property == "PointB" then
					B.From = Value; C.To = Value
				elseif Property == "PointC" then
					C.From = Value; D.To = Value
				elseif Property == "PointD" then
					D.From = Value; A.To = Value
				elseif Property == "Visible" then
					A.Visible = Value; B.Visible = Value; C.Visible = Value; D.Visible = Value
				elseif Property == "Filled" then
					-- Filled not easily supported with UI shapes; skipping or approximate
					-- keep as no-op for now
				elseif Property == "Color" then
					A.Color = Value; B.Color = Value; C.Color = Value; D.Color = Value
				elseif Property == "ZIndex" then
					A.ZIndex = Value; B.ZIndex = Value; C.ZIndex = Value; D.ZIndex = Value
				end
				QuadProperties[Property] = Value
			end,
			__index = function(self, Property)
				if string.lower(tostring(Property)) == "remove" then
					return function()
						A:Remove(); B:Remove(); C:Remove(); D:Remove()
					end
				end
				return QuadProperties[Property]
			end
		})
		return proxy

	elseif drawingType == "Triangle" then
		local triangleObj = ({
			PointA = Vector2.new(),
			PointB = Vector2.new(),
			PointC = Vector2.new(),
			Thickness = 1,
			Filled = false
		} + baseDrawingObj)

		local la = DrawingLib.new("Line")
		local lb = DrawingLib.new("Line")
		local lc = DrawingLib.new("Line")

		la.Thickness = triangleObj.Thickness
		lb.Thickness = triangleObj.Thickness
		lc.Thickness = triangleObj.Thickness

		local proxy = setmetatable({__type = "Drawing Object"}, {
			__newindex = function(_, index, value)
				if typeof(triangleObj[index]) == "nil" then return end
				if index == "PointA" then la.From = value; lb.To = value
				elseif index == "PointB" then lb.From = value; lc.To = value
				elseif index == "PointC" then lc.From = value; la.To = value
				elseif (index == "Thickness" or index == "Visible" or index == "Color" or index == "ZIndex") then
					la[index] = value; lb[index] = value; lc[index] = value
				elseif index == "Filled" then
					-- Filled not supported via lines (no-op)
				end
				triangleObj[index] = value
			end,
			__index = function(self, index)
				if index == "Remove" or index == "Destroy" then
					return function()
						la:Remove(); lb:Remove(); lc:Remove()
						triangleObj.Remove(self)
					end
				end
				return triangleObj[index]
			end,
			__tostring = function() return "Drawing" end
		})
		return proxy
	end
end

-- kompatible Utility-Funktionen wie vorher
getgenv().Drawing = DrawingLib

getgenv().isrenderobj = function(obj)
	local s, r = pcall(function()
		return obj.__type == "Drawing Object"
	end)
	return s and r
end

getgenv().cleardrawcache = function()
	-- markiere alle entrys zum entfernen
	for i=#activeObjects,1,-1 do
		local e = activeObjects[i]
		e._removed = true
		if e.ui then
			pcall(function() e.ui:Destroy() end)
			e.ui = nil
		end
		if e.uiStroke then pcall(function() e.uiStroke:Destroy() end); e.uiStroke = nil end
		if e.uiCorner then pcall(function() e.uiCorner:Destroy() end); e.uiCorner = nil end
	end
	table.clear(activeObjects)
	-- optional: put existing pooled instances back - done via Destroy above
end

getgenv().getrenderproperty = function(obj, prop)
	assert(getgenv().isrenderobj(obj), "Object must be a Drawing", 3)
	return obj[prop]
end

getgenv().setrenderproperty = function(obj, prop, val)
	assert(getgenv().isrenderobj(obj), "Object must be a Drawing", 3)
	obj[prop] = val
end

-- End of improved Drawing library
